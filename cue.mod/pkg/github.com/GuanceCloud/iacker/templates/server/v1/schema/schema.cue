package schema

import (
    "strings"
	"encoding/json"
	gotemplate "text/template"

    naming "github.com/GuanceCloud/iacker/pkg/helpers/naming"
	template "github.com/GuanceCloud/iacker/pkg/template/v1"
)

inputs: template.#Inputs

resources: *inputs.resources | {}

// Generate JSON files
for rsname, rsinfo in resources {
	outputs: files: "internal/gen/schemas/\(strings.ToLower(rsname))/v1/\(strings.ToLower(rsname)).schema.json": template.#File & {
		content: json.Indent(json.Marshal(rsinfo), "", "  ")
	}
}

// Generate schema definitions
for rsname, rsinfo in resources {
	outputs: files: "internal/gen/schemas/\(strings.ToLower(rsname))/v1/\(strings.ToLower(rsname)).schema.go": template.#File & {
		_template: """
			// Code generated by Iacker. DO NOT EDIT.
			package v1

			import (
				_ "embed"

				"github.com/GuanceCloud/iacker-server/pkg/schema"
			)

			// ResourceType is the unique type name of {{ .name }}
			const ResourceType = "{{ .name }}"

			//go:embed {{ .lowername }}.schema.json
			var schemaBytes []byte

			// Schema is the schema of {{ .name }}
			var Schema schema.Schema

			func init() {
				baseSchema, err := schema.NewFromBytes(ResourceType, schemaBytes)
				if err != nil {
					panic(err)
				}
				Schema = &resourceSchema{
					BaseSchema: baseSchema,
				}
			}

			{{ range $varname, $enum := .consts }}
			const (
				{{- range $_, $item := $enum }}
				// {{ $varname }}{{ $item.name }} is the value of {{ $item.title }}
				{{ $varname }}{{ $item.name }} = {{ $item.value }}
				{{- end }}
			)
			{{ end }}

			// resourceSchema is the schema of {{ .name }}
			type resourceSchema struct {
				*schema.BaseSchema
			}

			// ReferenceTypes returns the related resource types of {{ .name }}
			func (s *resourceSchema) ReferenceTypes() []string {
				return []string{
					{{- range $ref, $pkg := .refs }}
						"{{ $ref }}",
					{{- end }}
				}
			}
			"""

		content: gotemplate.Execute(_template, {
			name: rsname
			lowername: strings.ToLower(rsname)
			consts: {
				for mname, minfo in rsinfo.models {
					for pinfo in minfo.properties {
						if pinfo.schema.enum != _|_ {
							"\(mname)\((naming.#Snake & { name: pinfo.name }).uppercamel)": [
								for item in pinfo.schema.enum {
									{
										"name": (naming.#Snake & { "name": item.name }).uppercamel
										if pinfo.schema.type == "string" {
											value: "\"\(item.value)\""
										}
										if pinfo.schema.type != "string" {
											value: item.value
										}
										title: item.title.en
									}
								},
							]
						}

						if pinfo.schema.type == "array" && pinfo.schema.elem.enum != _|_ {
							"\(mname)\((naming.#Snake & { name: pinfo.name }).uppercamel)": [
								for item in pinfo.schema.elem.enum {
									{
										"name": (naming.#Snake & { "name": item.name }).uppercamel
										if pinfo.schema.elem.type == "string" {
											value: "\"\(item.value)\""
										}
										if pinfo.schema.elem.type != "string" {
											value: item.value
										}
										title: item.title.en
									}
								},
							]
						}
					}
				}
			}

			refs: {
				for mname, minfo in rsinfo.models {
					for pinfo in minfo.properties {
						if pinfo.schema.ref != _|_ {
							"\(pinfo.schema.ref)": pinfo.schema.ref == rsname
						}

						if pinfo.schema.type == "array" && pinfo.schema.elem.ref != _|_ {
							"\(pinfo.schema.elem.ref)": pinfo.schema.elem.ref == rsname
						}
					}
				}
			}
		})
	}
}
